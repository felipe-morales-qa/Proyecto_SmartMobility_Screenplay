"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerEventStreamWriter = void 0;
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const core_1 = require("@serenity-js/core");
const model_1 = require("@serenity-js/core/lib/model");
class WorkerEventStreamWriter {
    outputDirectory;
    workerInfo;
    stage;
    beforeAllId; //  = new CorrelationId('unknown');
    activeSceneId; // = WorkerEventStreamWriter.beforeTest;
    events = new Map();
    static workerStreamIdFor(workerIndex) {
        return new model_1.CorrelationId(`worker-${workerIndex}`);
    }
    constructor(outputDirectory, workerInfo, stage) {
        this.outputDirectory = outputDirectory;
        this.workerInfo = workerInfo;
        this.stage = stage;
        this.beforeAllId = WorkerEventStreamWriter.workerStreamIdFor(this.workerInfo.workerIndex);
        this.activeSceneId = this.beforeAllId;
        this.events.set(this.beforeAllId.value, []);
    }
    assignedTo(stage) {
        this.stage = stage;
        return this;
    }
    notifyOf(event) {
        if (this.isSceneEvent(event) && !this.activeSceneExistsFor(event)) {
            this.activateScene(event);
        }
        this.events.get(this.activeSceneId.value).push(event);
    }
    isSceneEvent(event) {
        return event['sceneId'] instanceof model_1.CorrelationId;
    }
    activeSceneExistsFor(event) {
        return this.activeSceneId.equals(event.sceneId);
    }
    activateScene(event) {
        this.activeSceneId = event.sceneId;
        const testId = event.sceneId.value;
        if (!this.events.has(testId)) {
            this.events.set(testId, []);
        }
        this.events.get(testId).push(...this.events.get(this.beforeAllId.value));
        this.events.set(this.beforeAllId.value, []);
    }
    async persistAll(workerBeforeAllSceneId) {
        const testIds = [...this.events.keys()];
        await Promise.all(testIds.map(testId => this.persist(testId, workerBeforeAllSceneId)));
    }
    async persist(testId, workerBeforeAllSceneId) {
        const testOutputDirectory = node_path_1.default.join(this.outputDirectory, testId);
        const filePath = node_path_1.default.join(testOutputDirectory, 'events.ndjson');
        const events = this.flush(testId);
        if (events.length === 0) {
            return;
        }
        await node_fs_1.default.promises.mkdir(testOutputDirectory, { recursive: true });
        for (const event of events) {
            const shouldReattachToScene = event['sceneId'] && event['sceneId'].equals(workerBeforeAllSceneId);
            const type = event.constructor.name;
            const value = shouldReattachToScene
                ? ({ ...event.toJSON(), sceneId: testId })
                : event.toJSON();
            const serialisedEvent = JSON.stringify({ type, value }, undefined, 0);
            await node_fs_1.default.promises.appendFile(filePath, serialisedEvent + '\n');
        }
    }
    flush(testId) {
        if (!this.events.has(testId)) {
            throw new core_1.LogicError(`No events recorded for test with id ${testId}`);
        }
        const events = this.events.get(testId);
        this.events.set(testId, []);
        return events;
    }
}
exports.WorkerEventStreamWriter = WorkerEventStreamWriter;
//# sourceMappingURL=WorkerEventStreamWriter.js.map