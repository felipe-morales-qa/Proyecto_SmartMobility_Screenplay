"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProxyBypass = void 0;
const createUrl_1 = require("./createUrl");
class ProxyBypass {
    static create(value) {
        if (value === undefined || value === '') {
            return new BypassNone();
        }
        if (value === '*') {
            return new BypassAll();
        }
        return new BypassMatching(value);
    }
}
exports.ProxyBypass = ProxyBypass;
class BypassNone extends ProxyBypass {
    matches(url_) {
        return false;
    }
}
class BypassAll extends ProxyBypass {
    matches(url_) {
        return true;
    }
}
class BypassHostnamePattern extends ProxyBypass {
    hostname;
    port;
    static template = /^((?<hostname>[^:]+)(:(?<port>\d+))?)$/;
    static defaultPorts = {
        'ftp:': '21',
        'gopher:': '70',
        'http:': '80',
        'https:': '443',
        'ws:': '80',
        'wss:': '443',
    };
    static create(patternConfig) {
        const { hostname, port } = this.template.exec(patternConfig)?.groups || {};
        return new BypassHostnamePattern(hostname, port);
    }
    constructor(hostname, port) {
        super();
        this.hostname = hostname;
        this.port = port;
    }
    matches(url) {
        const urlPort = url.port || BypassHostnamePattern.defaultPorts[url.protocol];
        return url.hostname.endsWith(this.hostname)
            && (this.port ? urlPort === this.port : true);
    }
}
class BypassMatching extends ProxyBypass {
    patterns;
    constructor(value) {
        super();
        this.patterns = value.split(',').map(patternConfig => BypassHostnamePattern.create(patternConfig.trim()));
    }
    matches(url) {
        const normalisedUrl = (0, createUrl_1.createUrl)(url);
        for (const pattern of this.patterns) {
            if (pattern.matches(normalisedUrl)) {
                return true;
            }
        }
        return false;
    }
}
//# sourceMappingURL=ProxyBypass.js.map